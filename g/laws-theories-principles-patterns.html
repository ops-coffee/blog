<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="applicable-device" content="pc,mobile">
  <meta name="keywords" content="None" />
  <meta name="description" content="None" />
  <link rel="alternate" type="application/rss+xml" title="运维咖啡吧" href="https://blog.ops-coffee.cn/feed.xml" />
  <link rel="stylesheet" href="https://blog.ops-coffee.cn/static/posts/css/ops-coffee.min.css" type="text/css" />

  <!-- Begin SEO tag -->
  <title>软件开发过程中那些有用的定律、理论、原则和模式</title>
  <meta property="og:locale" content="zh_CN" />
  <meta property="og:site_name" content="运维咖啡吧" />
  <meta property="og:url" content="https://blog.ops-coffee.cn" />
  <meta property="og:title" content="软件开发过程中那些有用的定律、理论、原则和模式" />
  <meta property="og:description" content="None" />
  <link rel="canonical" href="https://blog.ops-coffee.cn" />
  <!-- End SEO tag -->
</head>

<body>
  <div class="header">
    <div class="container no-sidebar">
      <nav class="header-site">
        <ul>
          <li><a href="/">首页</a></li>
            <li class="has-submenu">
              <a href="#" target="_self">运维</a>
              <ul class="sub-menu">
                <li><a href="/tag/系统运维/" target="_self">系统运维</a></li>
                <li><a href="/elk/index.html" target="_self">ELK系列</a></li>
                <li><a href="/ldap/index.html" target="_self">LDAP系列</a></li>
              </ul>
            </li>
            <li class="has-submenu">
              <a href="#" target="_self">开发</a>
              <ul class="sub-menu">
                <li><a href="/tag/Devops/" target="_self">DevOps</a></li>
                <li><a href="/tag/Python/" target="_self">Python</a></li>
                <li><a href="/tag/Django/" target="_self">Django</a></li>
                <li><a href="/bpmn/index.html" target="_self">BPMN系列</a></li>
                <li><a href="/webssh/index.html" target="_self">WebSSH系列</a></li>
                <li><a href="/frontend/index.html" target="_self">前端开发系列</a></li>
              </ul>
            </li>
            <li><a href="/devops.html" target="_self">运维平台</a></li>
            <li><a href="/tag/这是生活/" target="_self">这是生活</a></li>
            <li class="has-submenu">
              <a href="#" target="_self">房车旅行</a>
              <ul class="sub-menu">
                <li><a href="/r/index.html" target="_self">房车体验</a></li>
                <li><a href="/travels.html" target="_self">旅行游记</a></li>
              </ul>
            </li>
            <li><a href="/tag/index.html" target="_self">标签</a></li>
            <li><a href="/archive.html" target="_self">归档</a></li>
        </ul>
      </nav>
    </div>
  </div>

  <header>
    <div class="container no-sidebar">
      <a href="/">
        <h1>运维咖啡吧</h1>
        <h2>享受技术带来的乐趣，体验生活给予的感动</h2>
      </a>
    </div>
  </header>

  <div id="content-wrap">
    <div class="container no-sidebar">
        <h1 id="art-title">软件开发过程中那些有用的定律、理论、原则和模式</h1>

        <h2 id="_1">介绍</h2>
<p>当人们谈论开发时，会聊到许多定律。这里收录了一些对开发人员有用的定律、理论、原则和模式。</p>
<p>原文地址为：https://github.com/dwmkerr/hacker-laws</p>
<h2 id="_2">定律</h2>
<h3 id="amdahls-law">阿姆达尔定律 (Amdahl's Law)</h3>
<blockquote>
<p>阿姆达尔定律是一个显示计算任务<strong>潜在加速</strong>能力的公式。这种能力可以通过增加系统资源来实现，通常用于并行计算中。它可以预测增加处理器数量的实际好处，然而增加处理器数量会受到程序并行性的限制。</p>
</blockquote>
<p>举例说明：如果程序由两部分组成，部分 A 必须由单个处理器执行，部分 B 可以并行运行。那么向执行程序的系统添加多个处理器只能获得有限的好处。它可以极大地提升部分 B 的运行速度，但部分 A 的运行速度将保持不变。</p>
<h3 id="the-broken-windows-theory">破窗效应 (The Broken Windows Theory)</h3>
<p>在破窗理论中认为，一些明显的犯罪迹象(或缺乏环保意识)会导致进一步的、更严重的犯罪(或环境的进一步恶化)。</p>
<p>破窗理论已应用于软件开发中，它表明劣质代码(或 <a href="#TODO" target="_blank">Technical Debt</a>)可能会影响后续优化的效率，从而进一步造成代码劣化；随着时间的推移，这种效应将会导致代码质量大幅下降。</p>
<h3 id="brookss-law">布鲁克斯法则 (Brooks's Law)</h3>
<blockquote>
<p>软件开发后期，添加人力只会使项目开发得更慢。</p>
</blockquote>
<p>这个定律表明，在许多情况下，试图通过增加人力来加速已延期项目的交付，将会使项目交付得更晚。布鲁克斯也明白，这是一种过度简化。但一般的论据是，新资源的时间增加和通信开销，会在短期内使开发速度减慢。而且，许多任务是密不可分的，换句话说，这样可以使更多的资源之间能轻易分配，这也意味着潜在的速度增长也更低。</p>
<p>谚语 <strong>九个女人不能在一个月内生一个孩子</strong> 与布鲁克斯法则同出一辙，特别是某些不可分割或者并行的工作。</p>
<h3 id="conways-law">康威定律 (Conway's Law)</h3>
<p>这个定律说明了系统的技术边界可以反应一个组织的结构，它通常会在改进组织时被提及。康威定律表明，如果一个组织被分散成许多小而无联系的单元，那么它开发的软件也是小而分散的。如果组织是更多地围绕以功能或服务为导向的<strong>垂直</strong>结构，那么软件系统也会反映这一点。</p>
<h3 id="cunninghams-law">坎宁汉姆定律 (Cunningham's Law)</h3>
<blockquote>
<p>在网络上想得到正确答案的最好方法不是提问题，而是发布一个错误的答案。</p>
</blockquote>
<p>据史蒂芬·麦克基迪说，沃德·坎宁汉姆早在 20 世纪 80 年代早期的时候建议他，在互联网上获得正确答案的最好方法不是提问题，而是发布一个错误的答案。麦克基迪称这为坎宁汉姆定律，而坎宁汉姆不以为然，并觉得这是“错误的引用”。最初这条定律只是用于描述 Usenet 上的社交行为，但后来也渐渐用于其他的在线社区（如 Wikipedia、Reddit、Twitter、Facebook 等）。</p>
<h3 id="dunbars-number">邓巴数字 (Dunbar's Number)</h3>
<p>邓巴数字是对一个人能够保持稳定社会关系的人数的认知极限——在这种关系中，一个人知道每个人是谁，也知道每个人与其他人的关系如何。而对这一数字的确切值则有着一些不同意见。邓巴指出，人仅能轻松地维持 150 个稳定的关系。这样的关系在一个更社会化的背景中，便是当你碰巧在酒吧里碰到这些人时候，你不会因为加入他们而感到尴尬。邓巴数字的估计值一般在 100 至 250 之间。</p>
<p>和人与人之间稳定的关系一样，开发人员与代码库的关系也需要努力维护。当面对大型、复杂的项目，或许多项目的归属权时，我们会依赖于约定、策略和建模过程来进行扩展。邓巴数字不仅在办公室规模的扩大的过程中举足轻重，而且在设置团队工作范围，或决定系统何时应该注重于辅助建模和组织管理开销自动化的工具时，也是非常重要的。将邓巴数字放入工程内容中进行类比，那就是您能加入并有信心随叫随到进行轮换的项目数(亦或是单个项目的规范化复杂性)。</p>
<h3 id="galls-law">盖尔定律 (Gall's Law)</h3>
<blockquote>
<p>一个切实可行的复杂系统势必是从一个切实可行的简单系统发展而来的。从头开始设计的复杂系统根本不切实可行，无法修修补补让它切实可行。你必须由一个切实可行的简单系统重新开始。</p>
</blockquote>
<p>盖尔定律说明了设计高度复杂的系统很可能会失败。它们很难一蹴而就，更多是从简单的系统逐渐演变而来。</p>
<p>最典型的例子便是互联网。如今的互联网是一个高度复杂的系统，而它最早只是被定义为一种在学术机构之间共享内容的方式。互联网成功实现了最初的目标，并且随着时间不断演化，最终成就了如今的复杂繁荣。</p>
<h3 id="goodharts-law">古德哈特定律 (Goodhart's Law)</h3>
<blockquote>
<p>当压力施于其上以进行控制时，任何观测到的统计恒性都倾向消散。</p>
</blockquote>
<p>另见：</p>
<blockquote>
<p>当一个措施本身成为目标时，它就不再是一个好的措施。</p>
</blockquote>
<p>根据这一定律，由测量驱动的优化反而可能导致测量结果本身的说服力下降。盲目使用一些过度严格筛选的方法 (KPIs) 可能会产生一些不良的影响。人们会倾向于用“钻空子”的行为去做局部优化，从而满足一些特定的度量标准，而不会在意整体的结果。</p>
<p>现实中的例子：</p>
<ul>
<li>Assert-free 测试可以达到代码覆盖率的预期，但度量的目的应该是创造经过良好测试的软件。</li>
<li>由 commits 的行数来评价开发人员的表现，从而导致了不合理的代码库扩增。</li>
</ul>
<h3 id="hanlons-razor">汉隆的剃刀 (Hanlon's Razor)</h3>
<blockquote>
<p>能解释为愚蠢的，就不要解释为恶意的。</p>
</blockquote>
<p>这一原则表明，一个行为所产生的消极结果并不是恶意。相反，消极结果更有可能归咎于这些没有得到充分理解的行动或影响。</p>
<h3 id="hofstadters-law">侯世达定律 (Hofstadter's Law)</h3>
<blockquote>
<p>即使考虑到侯世达定律，它也总是比你预期的要长。</p>
</blockquote>
<p>在估计需要多长时间开发时，你可能会听到此定律。软件开发似乎有这样一条定理，即我们往往不能准确地估计需要多长时间才能完成。</p>
<h3 id="hutbers-law">哈伯特定律 (Hutber's Law)</h3>
<blockquote>
<p>改善即恶化。</p>
</blockquote>
<p>这个定律说明了对一个系统的改进会导致其他部分的恶化；或者它会将其他的恶化隐藏起来，并导致系统整体状态的退化。</p>
<p>例如，某个端点的响应延迟减少，就可能导致请求流中的吞吐量和容量问题进一步增加，并影响到另一个完全不同的子系统。</p>
<h3 id="the-hype-cycle-or-amaras-law">技术成熟度曲线 (The Hype Cycle or Amara's Law)</h3>
<blockquote>
<p>我们倾向于过高估计技术在短期内的影响，并低估长期效应。</p>
</blockquote>
<p>技术成熟度曲线是<a href="#TODO" target="_blank">高德纳咨询公司</a>对技术最初兴起和发展的视觉展现。一图顶千言：</p>
<p><img alt="" loading="lazy" src="/static/images/2020/0219.png" /></p>
<p>简而言之，这个周期表明，新技术及其潜在影响通常会引发一阵浪潮。团队快速使用这些新技术，有时会对结果感到失望。这可能是因为该技术还不够成熟，或者现实应用还没有完全实现。经过一段时间后，技术的能力提高了，使用它的实际机会会增加，最终团队也可以提高工作效率。罗伊·阿马拉简洁地总结了这一点：我们倾向于高估技术短期内的影响，并低估长期效应。</p>
<h3 id="hyrums-law-or-the-law-of-implicit-interfaces">隐式接口定律 (Hyrum's Law or The Law of Implicit Interfaces)</h3>
<blockquote>
<p>当 API 有足够多的用户时，你在合同中的承诺已不重要：你系统的所有可观察行为都将被某些人所依赖。</p>
</blockquote>
<p>隐式接口定律表明，当你的 API 有足够多的用户时，API 的所有行为（包括那些未囊括在公共说明中的一部分）最终都会被其他人所依赖。 一个简单的例子是 API 的响应时间这种非功能性因素，还有一个更微妙的例子是：用户使用正则表达式判断错误信息的类型时，即使 API 的公共说明没有说明消息的内容，来指示用户错误的类型，一些用户也可能会使用并更改该消息，而这实际上会破坏 API 的使用。</p>
<h3 id="metcalfes-law">梅特卡夫定律 (Metcalfe's Law)</h3>
<blockquote>
<p>在网络理论中，系统的价值约等于系统用户数的平方。</p>
</blockquote>
<p>这个定律基于一个系统中可能的连接对数量，并且与<a href="#%e9%87%8c%e5%be%b7%e5%ae%9a%e5%be%8b-reeds-law" target="_blank">里德定律</a>十分相近。奥德利兹科 (Odlyzko) 和其他人认为，里德定律和梅特卡夫定律夸大了系统本身的价值，因为它们没有考虑到网络效应中人类认知的限制。</p>
<h3 id="moores-law">摩尔定律 (Moore's Law)</h3>
<blockquote>
<p>集成电路中的晶体管数量大约每两年翻一番。</p>
</blockquote>
<p>这条定律通常用于说明半导体和芯片技术提高的绝对速度。从 20 世纪 70 年代到 21 世纪前十年，摩尔的预测被证明是高度准确的。 近年来，这种趋势略有变化，部分原因受到<a href="#TODO" target="_blank">量子隧穿效应</a>影响。然而，并行化计算的进步以及半导体技术和量子计算潜在的革命性变化，可能意味着摩尔定律在未来几十年内继续保持正确。</p>
<h3 id="murphys-law-sods-law">墨菲定律 (Murphy's Law / Sod's Law)</h3>
<blockquote>
<p>凡是可能出错的事就一定会出错。</p>
</blockquote>
<p>出自 <a href="#TODO" target="_blank">爱德华·A·墨菲</a> ， <em>墨菲定律</em> 说明了如果一件事有可能出错，那么就一定会出错。</p>
<p>这是一句开发人员间的俗语，在开发、测试甚至在生产中都有可能会发生一些令人意想不到的事情。而这一定律也可以参考在英式英语中更为常见的 <em>索德定理</em> ：</p>
<blockquote>
<p>如果某件事可能出错，那么它一定会在最糟糕的时候发生。</p>
</blockquote>
<p>这些定律常常用于幽默嘲弄。但是，类似于 <a href="#TODO" target="_blank"><em>Confirmation Bias</em></a> 和 <a href="#TODO" target="_blank"><em>Selection Bias</em></a> 的现象很容易导致人们过分强调这些定律（即在大部分情况下，一件事的成功会显得司空见惯；而失败才会引起更多的注意和讨论）。</p>
<h3 id="occams-razor">奥卡姆剃刀 (Occam's Razor)</h3>
<blockquote>
<p>如无必要，勿增实体。</p>
</blockquote>
<p>奥卡姆剃刀指出，在几种可能的解决方案之中，最有可能的解决方案便是概念和假设最少的那个。因为这个解决方案最为简单，只解决了问题，并且没有引入额外的复杂度和可能的负面后果。</p>
<h3 id="parkinsons-law">帕金森定理 (Parkinson's Law)</h3>
<blockquote>
<p>在工作能够完成的时限内，工作量会一直增加，直到所有可用时间都被填满为止。</p>
</blockquote>
<p>基于官僚机构的研究背景，该定律被应用于软件开发中。该理论认为，团队在截止日期之前效率低下，然后在截止日期前赶紧完成工作，从而使实际截止日期变得随意。</p>
<p>将这个定理与<a href="#TODO" target="_blank">侯世达定律</a>相结合，则会获得更加悲观的观点：为了在规定时间内完成工作，工作将增多，花费比预期更长的时间。</p>
<h3 id="premature-optimization-effect">过早优化效应 (Premature Optimization Effect)</h3>
<blockquote>
<p>过早优化是万恶之源。</p>
</blockquote>
<p>在高德纳的《goto 语句的结构化编程》论文中，他写到：“程序员们浪费了大量的时间去思考或者担心他们的程序中的非关键部分的速度。而在考虑调试和维护的时候，这些所谓提高效率的做法实际上十分不妥。我们应该放弃小的效率点，并且要在 97% 的时间提醒自己，<strong>过早优化是万恶之源</strong>。而且连那关键的 3% 也不能够放过。”</p>
<p>然而，<em>过早优化</em> （简而言之）可以定义为在我们知道需要做什么之前进行优化。</p>
<h3 id="putts-law">普特定律 (Putt's Law)</h3>
<blockquote>
<p>技术由两类人主导，一类是纯粹的管理人员， 一类是纯粹的技术人员。</p>
</blockquote>
<p>普特定律常常遵循普特推论：</p>
<blockquote>
<p>每一个技术层次，假以时日，能力将逆转。</p>
</blockquote>
<p>这些结论表明，由于各种选择标准和群体组织的趋势，技术组织的工作层面将有一些技术人员，以及一些不了解复杂性和挑战的管理人员。这种现象可能是由于 <a href="#TODO" target="_blank">The Peter Principe</a> 或 <a href="#TODO" target="_blank">Dilbert's Law</a> 造成的。</p>
<p>但是，应该强调的是，诸如此类的定律是一种广泛的概括，可能适用于某些类型的组织，而不适用于其他组织。</p>
<h3 id="reeds-law">里德定律 (Reed's Law)</h3>
<blockquote>
<p>大型网络，尤其是社交网络的效用会随着网络的大小呈指数级扩增。</p>
</blockquote>
<p>这一定律基于图论，图论中的效用与可能的子组数量呈正比，并且该增长速度会比参与者的数量和可能的连接对数量要快。奥德利兹科 (Odlyzko) 和其他人认为，里德定律夸大了系统本身的价值，因为它们没有考虑到网络效应中人类认知的限制。</p>
<h3 id="the-law-of-conservation-of-complexity-or-teslers-law">复杂性守恒定律 (The Law of Conservation of Complexity or Tesler's Law)</h3>
<p>该定律表明系统中存在着一定程度的复杂性，并且不能减少。</p>
<p>系统中的某些复杂性是<strong>无意的</strong>。这是由于结构不良，错误或者糟糕的建模造成的。这种无意的复杂性可以减少或者消除。然而，由于待解决问题固有的复杂性，某些复杂性是<strong>内在的</strong>。这种复杂性可以转移，但不能消除。</p>
<p>该定律有趣的一点是，即使简化整个系统，内在的复杂性也不会降低。它会<strong>转移到用户</strong>，并且用户必须以更复杂的方式行事。</p>
<h3 id="the-law-of-leaky-abstractions">抽象泄漏定律 (The Law of Leaky Abstractions)</h3>
<blockquote>
<p>在某种程度上，所有非平凡的抽象都是有泄漏的。</p>
</blockquote>
<p>该定律指出，通常用于简化复杂系统的抽象，在某些情况下将底层系统泄漏出来，使得抽象表现出意外的行为。</p>
<p>例如加载文件并读取其内容。文件系统 API 是较低级别内核系统的抽象，它们本身是与磁盘（或 SSD 的闪存）上的数据更改相关的物理过程的抽象。在大多数情况下，处理文件（如二进制数据流）的抽象将起作用。但是，对于磁盘驱动器，顺序读取数据将比随机访问快得多（由于页面错误的开销增加）。但对于 SSD 驱动器，此开销不会出现。需要理解基础细节来处理这种情况（例如，数据库索引文件的良好结构可以减少随机访问的开销），开发人员需要合理的抽象，来处理不同的细节。</p>
<p>当引入更多的抽象时，上面的例子会变得更复杂。Linux 操作系统允许通过网络访问文件，但在本地表示为<strong>普通</strong>文件。如果存在网络故障，这种抽象将会<strong>泄漏</strong>。如果开发人员将这些文件视为<strong>普通</strong>文件，而不考虑它们可能会受到网络延迟和故障的影响，那么解决方案就会出错。</p>
<p>描述该定律的文章表明，过度依赖抽象，加上对底层过程的理解不足，实际上使得问题在某些情况下更加复杂。</p>
<p>真实的例子：</p>
<ul>
<li>Photoshop 启动缓慢：我过去遇到过一个问题，就是 Photoshop 启动缓慢，有时需要几分钟。问题好像是 Photoshop 启动时，会读取当前默认打印机的一些信息。但是，如果该打印机实际上是一台网络打印机，则可能需要很长的时间。将网络打印机与本地打印机当作同样的抽象，导致连接不良的情况下出现问题。</li>
</ul>
<h3 id="the-law-of-triviality">帕金森琐碎定理 (The Law of Triviality)</h3>
<p>该定理显示，群体将给予更多的时间和注意力来处理琐碎的问题，而不是用来处理严肃而实质性的问题。</p>
<p>常见的虚构例子是委员会批准核电站的计划，他们大部分时间都在讨论自行车棚的结构，而不是电厂本身等更为重要的设计。如果没有大量的专业知识或者准备，很难给非常大的复杂主题讨论提供宝贵的意见。但是，人们希望看到更多意见。因此，他们倾向于将大量时间集中在很容易推敲，但不一定被看重的小细节上。</p>
<p>由上面的虚构例子产生了 <strong>Bike Shedding</strong> 的说法，以形容在琐碎细节上浪费时间这一行为。</p>
<h3 id="unix-the-unix-philosophy">Unix 哲学 (The Unix Philosophy)</h3>
<p>Unix 哲学指软件组件应该很小，并专注于做一件特定的事情。将小而简单以及定义良好的单元组合在一起，而不是使用大而复杂的多用途程序，可以更轻松地构建系统。</p>
<p>像<strong>微服务架构</strong>这种现代实践可以认为是这种哲学的应用，其中服务很小，集中于做一件特定的事情，由简单的构建块组成复杂的行为。</p>
<h3 id="spotify-the-spotify-model">Spotify 模型 (The Spotify Model)</h3>
<p>Spotify 模型是团队和组织结构的一种方法，已被 Spotify 实验室推广开来。在此模型中，团队围绕功能而非技术进行组织。</p>
<p>Spotify 模型还普及了部落、行会以及章节的概念，这些是组织结构的其他组成部分。</p>
<h3 id="wadlers-law">沃德勒定律 (Wadler's Law)</h3>
<blockquote>
<p>任何语言设计中，讨论下面列表中某个要素所花费的总时间与其位置成正比。</p>
<ol>
<li>语义 (Semantics)</li>
<li>语法 (Syntax)</li>
<li>词法 (Lexical syntax)</li>
<li>注释语法 (Lexical syntax of comments)</li>
</ol>
<p>（简而言之，在语义上花费一个小时，就要在注释语法上花费八个小时）。</p>
</blockquote>
<p>与 <a href="#TODO" target="_blank">帕金森琐碎定理</a> 类似, 沃德勒定律指出，在设计语言时，与这些特征的重要性相比，花在语言结构上的时间过多。</p>
<h3 id="wheatons-law">惠顿定律 (Wheaton's Law)</h3>
<blockquote>
<p>不要像个傻子一样。</p>
</blockquote>
<p>这条定律由威尔 · 惠顿（曾出演过星际迷航：下一代、生活大爆炸）创造，这个简洁而有力的定律旨在专业组织内营造和谐和尊重的环境。它可以在与同事交谈、代码审查、反驳观点和批评的时候派上用场。而且通常情况下，人们之间的专业交互也同样适用。</p>
<h2 id="_3">原则</h2>
<p>原则通常是与设计相关的准则。</p>
<h3 id="the-dilbert-principle">呆伯特法则 (The Dilbert Principle)</h3>
<blockquote>
<p>公司会倾向于系统地将工作能力差的员工提升到管理层，以使他们脱离工作流程。</p>
</blockquote>
<p>呆伯特原则是由史考特·亚当斯 (Dilbert 漫画连环画的创建者) 开发的一个管理概念，灵感来源于<a href="#%e5%bd%bc%e5%be%97%e5%8e%9f%e7%90%86-the-peter-principle" target="_blank">彼得原理</a>。根据呆伯特原则，工作能力差的员工会被提升到管理层，从而限制他们所能造成的损害。亚当斯首先在 1995 年《华尔街日报》的一篇文章中解释了这一原则，随后在他 1996 年的商业书籍《呆伯特原则》中进行了扩展。</p>
<h3 id="the-pareto-principle-or-the-8020-rule">帕累托法则 (The Pareto Principle or The 80/20 Rule)</h3>
<blockquote>
<p>生活中大多数事情不是均匀分布的。</p>
</blockquote>
<p>帕累托法则可以帮你认识到大多数结果来自少数投入：</p>
<ul>
<li>某个软件的 80％ 代码只占了总分配时间的 20％（相反，最难的 20％ 代码部分占用了 80％ 的时间）</li>
<li>20％ 的努力产生了 80％ 的结果</li>
<li>20％ 的工作创造了 80％ 的收入</li>
<li>20％ 的错误导致了 80％ 的崩溃</li>
<li>20％ 的功能导致了 80％ 的使用量</li>
</ul>
<p>在 20 世纪 40 年代，公认为质量控制之父的美国罗马尼亚工程师约瑟夫·朱兰博士，<a href="#TODO" target="_blank">开始将帕累托法则应用于质量问题</a>。</p>
<p>这个原则也被称为<strong>二八法则</strong>，<strong>重要的少数法则</strong>和<strong>因素稀疏原则</strong>。</p>
<p>现实的例子：</p>
<ul>
<li>微软 2002 年的报告表明，修复最常出现的 20％ 错误，将消除 Windows 和 Office 中 80％ 的错误和崩溃。</li>
</ul>
<h3 id="the-peter-principle">彼得原理 (The Peter Principle)</h3>
<blockquote>
<p>在等级制度中，人往往会被提升到他们的“无法胜任的水平”。</p>
</blockquote>
<p>这是由劳伦斯·彼得提出的一个管理概念。彼得原理认为，擅长工作的人会得到提升，直到他们达到不再成功的水平 (即他们所“无法胜任的水平”)。基于此，由于他们资历更高，被公司开除的可能性较小 (除非他们表现非常糟糕)。而且他们将继续担任几乎没有本职技能的职位，即使那些原本让他们成功的能力在新工作中并无必要。</p>
<p>有的工程师对此特别感兴趣，它们最初从事的是深度的技术工作，但走上了<strong>管理</strong>其他工程师的职业道路——这意味着需要一个完全不同的技能树。</p>
<h3 id="the-robustness-principle-or-postels-law">鲁棒性原则 (The Robustness Principle or Postel's Law)</h3>
<blockquote>
<p>在自己所做的事情上要保守, 在接受别人的事情上要自由。</p>
</blockquote>
<p>通常应用于服务器应用程序开发中，该原则指出，你发送给其他人的内容应尽可能最小且符合要求，并且处理不符合要求的输入。</p>
<p>该原则的目标是构建稳健的系统。如果可以理解意图，它们可以处理不良的输入。但是，接受错误格式的输入可能存在安全隐患，特别是此类的输入未经过充分测试。</p>
<h3 id="solid">SOLID</h3>
<p>这是一个缩写，指的是：</p>
<ul>
<li>S：<a href="#TODO" target="_blank">单一功能原则 (The Single Responsibility Principle)</a></li>
<li>O：<a href="#TODO" target="_blank">开闭原则 (The Open/Closed Principle)</a></li>
<li>L：<a href="#TODO" target="_blank">里氏替换原则 (The Liskov Substitution Principle)</a></li>
<li>I：<a href="#TODO" target="_blank">接口隔离原则 (The Interface Segregation Principle)</a></li>
<li>D：<a href="#TODO" target="_blank">依赖反转原则 (The Dependency Inversion Principle)</a></li>
</ul>
<p>这些是 <a href="#todo" target="_blank">Object-Oriented Programming</a> 的关键原则。诸如此类的设计原则能够帮助开发人员构建更易于维护的系统。</p>
<h3 id="the-single-responsibility-principle">单一功能原则 (The Single Responsibility Principle)</h3>
<blockquote>
<p>每个模块或者类只应该有一项功能。</p>
</blockquote>
<p><a href="#solid" target="_blank">SOLID</a> 的第一个原则。这个原则表明模块或者类只应该做一件事。实际上，这意味着对程序功能的单个小更改，应该只需要更改一个组件。例如，更改密码验证复杂性的方式应该只需要更改程序的一部分。</p>
<p>理论上讲，这使代码更健壮，更容易更改。知道正在更改的组件只有一个功能，这意味着测试更改更容易。使用前面的例子，更改密码复杂性组件应该只影响与密码复杂性相关的功能。变更具有许多功能的组件可能要困难得多。</p>
<h3 id="the-openclosed-principle">开闭原则 (The Open/Closed Principle)</h3>
<blockquote>
<p>实体应开放扩展并关闭修改。</p>
</blockquote>
<p><a href="#solid" target="_blank">SOLID</a> 的第二个原则。这个原则指出实体（可以是类、模块、函数等）应该能够使它们的行为易于扩展，但是它们的扩展行为不应该被修改。</p>
<p>举一个假设的例子，想象一个能够将 Markdown 转换为 HTML 的模块。如果可以扩展模块，而不修改内部模块来处理新的 markdown 特征，而无需修改内部模块，则可以认为是开放扩展。如果用户不能修改处理现有 Markdown 特征的模块，那么它被认为是关闭修改。</p>
<p>这个原则与面向对象编程紧密相关，让我们可以设计对象以便于扩展，但是可以避免以意想不到的方式改变其现有对象的行为。</p>
<h3 id="the-liskov-substitution-principle">里氏替换原则 (The Liskov Substitution Principle)</h3>
<blockquote>
<p>可以在不破坏系统的情况下，用子类型替换类型。</p>
</blockquote>
<p><a href="#solid" target="_blank">SOLID</a> 的第三个原则。该原则指出，如果组件依赖于类型，那么它应该能够使用该类型的子类型，而不会导致系统失败或者必须知道该子类型的详细信息。</p>
<p>举个例子，假设我们有一个方法，读取 XML 文档。如果该方法使用基类型 <strong>file</strong>，则从 <strong>file</strong> 派生的任何内容，都能用在该方法中。 如果 <strong>file</strong> 支持反向查找，并且 xml 解析器使用该函数，但是派生类型 <strong>network file</strong> 尝试反向查找时失败，则 <strong>network file</strong> 将违反该原则。</p>
<p>该原则与面向对象编程紧密相关，必须仔细建模、层次结构，以避免让系统用户混淆。</p>
<h3 id="the-interface-segregation-principle">接口隔离原则 (The Interface Segregation Principle)</h3>
<blockquote>
<p>不应强制任何客户端依赖于它不使用的方法。</p>
</blockquote>
<p><a href="#solid" target="_blank">SOLID</a> 的第四个原则。该原则指出组件的消费者不应该依赖于它实际上不使用的组件函数。</p>
<p>举一个例子，假设我们有一个方法，读取 XML 文档。它只需要读取文件中的字节，向前移动或向后移动。如果由于一个与文件结构不相关的功能发生更改（例如更新文件安全性的权限模型），需要更新此方法，则该原则已失效。文件最好实现 <strong>可查询流</strong> 接口，并让 XML 读取器使用该接口。</p>
<p>该原则与面向对象编程紧密相关，其中接口，层次结构和抽象类型用于不同组件的 <a href="#todo" target="_blank">minimise the coupling</a>。 <a href="#todo" target="_blank">Duck typing</a> 是一种通过消除显式接口来强制执行该原则的方法。</p>
<h3 id="the-dependency-inversion-principle">依赖反转原则 (The Dependency Inversion Principle)</h3>
<blockquote>
<p>高级模块不应该依赖于低级实现。</p>
</blockquote>
<p><a href="#solid" target="_blank">SOLID</a> 的第五个原则。该原则指出，更高级别的协调组件不应该知道其依赖项的详细信息。</p>
<p>举个例子，假设我们有一个从网站读取元数据的程序。我们假设主要组件必须知道下载网页内容的组件，以及可以读取元数据的组件。如果我们考虑依赖反转，主要组件将仅依赖于可以获取字节数据的抽象组件，然后是一个能够从字节流中读取元数据的抽象组件，主要组件不需要了解 TCP、IP、HTTP、HTML 等。</p>
<p>这个原则很复杂，因为它似乎可以反转系统的预期依赖性（因此得名）。实践中，这也意味着，单独的编排组件必须确保抽象类型的正确实现被使用（例如在前面的例子中，必须提供元数据读取器组件、HTTP 文件下载功能和 HTML 元标签读取器）。然后，这涉及诸如 <a href="#todo" target="_blank">Inversion of Control</a> 和 <a href="#todo" target="_blank">Dependency Injection</a> 之类的模式。</p>
<h3 id="the-dry-principle">不要重复你自己原则 (The DRY Principle)</h3>
<blockquote>
<p>系统中，每一块知识都必须是单一、明确而权威的。</p>
</blockquote>
<p>DRY 是 <strong>Do not Repeat Yourself</strong> 的缩写。这个原则旨在帮助开发人员减少代码的重复性，并将公共代码保存在一个地方。最初由安德鲁·亨特和戴夫·托马斯在 1999 年出版的《程序员修炼之道》中引用。</p>
<blockquote>
<p>与 DRY 相反的是 <em>WET</em>（功能实现两次或者喜欢打字 Write Everything Twice or We Enjoy Typing）。</p>
</blockquote>
<p>实际上，如果你在两个或更多的地方有相同的功能，你可以使用 DRY 原则将它们合并为一个，并在任何你需要的地方重复使用。</p>
<h3 id="kiss-the-kiss-principle">KISS 原则 (The KISS Principle)</h3>
<blockquote>
<p>保持简单和直白。</p>
</blockquote>
<p>KISS 原则指明了如果大多数的系统能够保持简单而非复杂化，那么他们便能够工作在最佳状态。因此，简单性应该是设计时的关键指标，同时也要避免不必要的复杂度。这个短语最初出自 1960 年的美国海军飞机工程师凯利 · 约翰逊 (Kelly Johnson)。</p>
<p>这一原则的最好例证便是约翰逊给设计工程师一些实用工具的故事。那时的他们正面临着一个挑战，即他们参与设计的喷气式飞机必须能够让普通的机械师在战场上仅仅用这些工具进行维修，因此，“直白”这个词应指的是损坏的事物本身和修复用工具的复杂度两者之间的关系，而非工程师们自身的能力水平。</p>
<h3 id="yagni">你不需要它原则 (YAGNI)</h3>
<p>这是 <em><strong>Y</strong>ou <strong>A</strong>ren't <strong>G</strong>onna <strong>N</strong>eed <strong>I</strong>t</em> 的缩写。</p>
<blockquote>
<p>只有当你需要某些东西的时候，才去实现它们，而不是在你预见的时候。</p>
</blockquote>
<p>极限编程原则告诫开发人员，他们应该只实现当前所需的功能，并避免实现未来需要的功能，仅在必要时才实现。</p>
<p>遵守这一原则可以减小代码库大小，同时避免时间和生产力浪费在没有价值的功能上。</p>
<h3 id="the-fallacies-of-distributed-computing">分布式计算的谬论 (The Fallacies of Distributed Computing)</h3>
<p>又称 <em>网络计算的谬误</em>，这是一系列关于分布式计算的猜想（或者看法），这些猜想可能会引起软件开发中的失败。这些假设是：</p>
<ul>
<li>网络可靠</li>
<li>延迟为零</li>
<li>带宽无限</li>
<li>网络安全</li>
<li>拓扑恒定</li>
<li>有管理员</li>
<li>运输成本为零</li>
<li>网络为同构的</li>
</ul>
<p>在设计弹性代码的时候，应该仔细考虑这些谬误，并假设其中任何一个谬误都可能引起处理分布式系统的复杂性和现实性时的逻辑缺陷。</p>

        <div>
          <ul style="display: inline-block;padding: 0;margin: 0 0 0.5em;color: #999;">
            <li style="display: inline-block;margin: 0 1em 0 0;"><a href="/g/laws-theories-principles-patterns.html">📅 2020-02-19</a></li>
          </ul>
        </div>

        <hr>

        <div class="nav-cell">
            <script async src="https://giscus.app/client.js"
                    data-repo="ops-coffee/blog" data-repo-id="MDEwOlJlcG9zaXRvcnkxNDY4OTI0MTg="
                    data-category="Announcements" data-category-id="DIC_kwDOCMFmgs4CQar3"
                    data-mapping="pathname" data-strict="0" data-reactions-enabled="1"
                    data-emit-metadata="0" data-input-position="top" data-theme="light"
                    data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous">
            </script>
        </div>

        <div>
            <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
            <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8944257246828217"
                 data-ad-slot="6731434232" data-ad-format="auto" data-full-width-responsive="true"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
        </div>

        <div class="nav-cell">
            <p class="nav-list-title">能看到这里一定是真爱，关注一下吧</p>
            <img alt="" loading="lazy" src="/static/images/wx.sou1.png" />
        </div>
    </div>
  </div>

  <footer class="footer">
    <div class="container">
      <div class="copy"> © ops-coffee</div>

      <div class="link">
        <a href="/search.html" title="搜索" target="_blank">搜索</a>
        <a href="/questions.html" title="提问" target="_blank">提问</a>
        <a href="/friends.html" title="友情链接" target="_blank">友链</a>
      </div>
    </div>
  </footer>
  
  <!-- Umami Cloud -->
<script async src="https://umami.ops-coffee.cn/script.js" data-website-id="a4aabd8e-32c7-40e7-a81c-119b909f2d0f"></script>

<!-- Google Adsense -->
<script data-ad-client="ca-pub-8944257246828217" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</body>

</html>